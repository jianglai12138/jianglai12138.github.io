<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Welcome to my blog</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-03-29T06:49:11.870Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>不秃头战士</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>STL</title>
    <link href="http://example.com/2023/03/29/STL/"/>
    <id>http://example.com/2023/03/29/STL/</id>
    <published>2023-03-29T06:40:47.000Z</published>
    <updated>2023-03-29T06:49:11.870Z</updated>
    
    <content type="html"><![CDATA[<p><b>第一部分</b><br>1.getline(标准输入流，字符串对象)<br>例如：</p><pre><code>getline(cin, s);  // 读入整行字符串，包括空格和换行符</code></pre><ol start="2"><li></li></ol><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;b&gt;第一部分&lt;/b&gt;&lt;br&gt;1.getline(标准输入流，字符串对象)&lt;br&gt;例如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;getline(cin, s);  // 读入整行字符串，包括空格和换行符
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;&lt;/li&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>数据结构笔记</title>
    <link href="http://example.com/2023/02/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/2023/02/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/</id>
    <published>2023-02-28T12:28:51.000Z</published>
    <updated>2023-04-07T13:22:36.656Z</updated>
    
    <content type="html"><![CDATA[<img src="/2023/02/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/绪论.jpg" width="200%" height="200%">---#线性表##顺序表<p>1.顺序表类型定义</p><pre><code>typedef struct&#123;    ElemType data[];    int length;&#125;SqList;</code></pre><p>ElemType理解为数据类型，区别是其可以随时更改为需要的类型，与typedef搭配使用。</p><p>例如在该程序前加上语句</p><pre><code>typedef int ElemType;//则data[]为int类型；</code></pre><p>2.顺序表的建立</p><pre><code>void CreateList(SqLIst *&amp;L,ElemType a[],int n)&#123;int i;L=(SqList *)malloc(sizeof(SqList));//为L分配空间for(i=0;i&lt;n;i++)    L-&gt;data[i]=a[i];//输入L的值L-&gt;length=n;    //L的长度为n&#125;</code></pre><p>3.顺序表的初始化</p><pre><code>//将L的存储空间的长度变为0即可void InitList(SqList *&amp;L)&#123;L=(SqList *)malloc(sizeof(SqList));L-&gt;length=0;&#125;</code></pre><p>4.顺序表的清空</p><pre><code>void DestroyList(SqList *&amp;L)&#123;free(L);&#125;</code></pre><p>5.判断是否为空</p><pre><code>int ListEmpty(SqList *&amp;L)&#123;    return(L-&gt;length==0)&#125;</code></pre><p>6.返回L的长度</p><pre><code>int ListLength(SqList *&amp;L)&#123;    return(L-&gt;length)&#125;</code></pre><p>7.输出L的值</p><pre><code>void DispList(SqList *&amp;L)&#123;if(ListEmpty(L)) return;//先判断L是否为0for(int i=0;i&lt;L-&gt;length;i++)    printf(&quot;%d&quot;,L-&gt;data[i]);printf(&quot;\n&quot;);&#125;</code></pre><p>8.获得L的第n个数据e</p><pre><code>int GetElem(SqList *&amp;L,int n,ElemType &amp;e)&#123;    if(n&lt;1||n&gt;L-&gt;length) return 0;//判断n是否为L数组的下标e=L-&gt;data[n-1];//n是指第n个数，对应下标为n-1return 1；&#125;</code></pre><p>9.定位e位于L的位置</p><pre><code>int LocateElem(SqList *L,ElemType e)&#123;int n=0;while(n&lt;L-&gt;length &amp;&amp; L-&gt;data[n]!=e) i++;if(n&gt;=L-&gt;length)    return 0;else    return n+1;//L的下标从0开始计数，因此0为第一个数，因此返回n+1&#125;</code></pre><p>10.插入e于L的第n位置</p><pre><code>int ListInsert(SqList *&amp;L,int n,ElemType e)&#123;if(n&lt;1 || n&gt;L-&gt;length+1)    return 0;n--;    //将顺序表的为序转化为下标for(int i=L-&gt;length;i&gt;n;i--)//将n后的元素后移一位    L-&gt;data[i]=L-&gt;data[i-1];L-&gt;data[n]=e;return 1;&#125;</code></pre><p>11.删除第n个元素，获得删除的e</p><pre><code>int ListDelete(SqList *&amp;L,int n,ElemType &amp;e)&#123;if(n&lt;1 || n&gt;L-&gt;length+1)    return 0;n--;e=L-&gt;data[n];for(int i=n;i &lt; L-&gt;length-1; i++)    L-&gt;data[i]=L-&gt;data[i+1];L-&gt;length--;return 1;&#125;</code></pre><p>12.合并LA，LB</p><pre><code>int UnionList(SqList *LA,SqList *LB,SqList *LC)&#123;    int i=0,j=0,l=0;while(i&lt;LA-&gt;length &amp;&amp; j&lt;LB-&gt;length)&#123; //LA,LC依次比较插入LC中    if(LA-&gt;data[i]&lt;LB-&gt;data[j])&#123;        LC-&gt;data[k]=LA-&gt;data[i];    i++;&#125;    else&#123;    LC-&gt;data[k]=LB-&gt;data[j];    j++;&#125;    k++;&#125;while(i&lt;LA-&gt;length)&#123;  //LA中有剩余插入到LC中LC-&gt;data[k]=LA-&gt;data[i];i++;k++;&#125;while(j&lt;LB-&gt;length)&#123;LC-&gt;data[k]=LB-&gt;data[j];j++;k++&#125;LC-&gt;length=k;return 1;&#125;</code></pre><p>13.main函数</p><pre><code>int main()&#123;SqList *L,*LA,*LB,*LC;int arr[]=&#123;10,20,30,40,50&#125;;CreateList(L,arr,5);printf(&quot;L:&quot;); DispList(L);printf(&quot;是否为空：%d\n&quot;,ListEmpty(L));printf(&quot;长度为：%d\n&quot;,ListLength(L));DestroyList(L);L=NULL;printf(&quot;清空L\n重新定义一个相同的L：&quot;);CreateList(L,arr,5);DispList(L);int e;GetList(L,3,e);printf(&quot;获得L的第3个数值e\ne=%d\n&quot;,e);printf(&quot;定位数据20的位置为：%d\n&quot;,LocateList(L,20));ListInsert(L,3,25);printf(&quot;插入25到第三位:&quot;);DispList(L);ListDelete(L,4,e);printf(&quot;删除第四位后：&quot;);DispList(L);printf(&quot;删除的元素e为：%d\n&quot;,e);int arrA[]=&#123;11,15,17,19,23&#125;;int arrB[]=&#123;10,16,18,20,25&#125;;int arrC[10]=&#123;&#125;;printf(&quot;LA:&quot;);CreateList(LA,arrA,5);DispList(LA);printf(&quot;LB:&quot;);CreateList(LB,arrB,5);DispList(LB);printf(&quot;合并后，LC:&quot;);CreateList(LC,arrC,5);UnionList(LA,LB,LC);DispList(LC);&#125;</code></pre><hr><p>##单链表<br>1.结构体</p><pre><code>typedef int ElemTypetypedef struct LNode&#123;    ElemType data;    struct LNode *next;&#125;LinkNode;</code></pre><p>2.头插法建立单链表</p><pre><code>void CreateListF(LinkNode *&amp;L,ElemType a[],int n)&#123;LinkNode *s;L=(LinkNode *)malloc(sizeof(LinkNode));L-&gt;next=NULL;for(int i=0;i&lt;n;i++)&#123;    s=(LinkNode *)malloc(sizeof(LinkNode));    s-&gt;data=a[i];    s-&gt;next=L-&gt;next;    &#125;&#125;</code></pre><p>3.尾插法建立单链表</p><pre><code>void CreateListR(LinkNode *&amp;L,ElemType a[],int n)&#123;LinkNode *s,*r;L = (LinkNode*)malloc(sizeof(LinkNode));L-&gt;next=NULL;r=L;for(int i=0;i&lt;n;i++)&#123;s = (LinkNode*)malloc(sizeof(LinkNode));s-&gt;data=a[i];r-&gt;next=s;r=s;    &#125;r-&gt;next=NULL;&#125;</code></pre><p>4.初始化链表</p><pre><code>void InitList(LinkNode *&amp;L)&#123;L=(LinkNode *)malloc(sizeof(LinkNode));L-&gt;next=NULL;&#125;</code></pre><p>5.清空链表</p><pre><code>void DestroyList(LinkNode *&amp;L)&#123;LinkNode *pre=L,*p=pre-&gt;next;while (p!=NULL)&#123;    free(pre);    pre=p;    p=pre-&gt;next;    &#125;free(pre);//此时p为NULL,pre指向尾结点,释放它&#125;</code></pre><p>6.判断是否为空</p><pre><code>bool ListEmpty(LinkNode *L)&#123;return(L-&gt;next==NULL);&#125;</code></pre><p>7.返回链表的长度</p><pre><code>int ListLength(LinkNode *L)&#123;LinkNode *p=L;int i=0;while(p-&gt;next!=NULL)&#123;    i++;    p=p-&gt;next;&#125;return i;&#125;</code></pre><p>8.输出单链表</p><pre><code>void DispList(LinkNode *L)&#123;    LinkNode *p=L-&gt;next;    while(p!=NULL)&#123;        printf(&quot;%d &quot;,p-&gt;data);        p=p-&gt;next;    &#125;    printf(&quot;\n&quot;);    &#125;</code></pre><p>9.获得单链表的第n个数e</p><pre><code>bool GetElem(LinkNode *L,int n,ElemType &amp;e)&#123;int i=0;LinkNode *p=L;if(n&lt;=0) return false;while(i&lt;n &amp;&amp; p!=NULL)&#123;    i++;    p=p-&gt;next;&#125;if(p==NULL)return false;else&#123;    e=p-&gt;data;    return true;&#125;&#125;</code></pre><p>10.定位e位于单链表的位置</p><pre><code>int LocateElem(LinkNode *L,ElemType e)&#123;LinkNode *p=L-&gt;next;int n=1;while(p!=NULL &amp;&amp; p-&gt;data!=e)&#123;    n++;    p=p-&gt;next;&#125;if(p==NULL)return 0;elsereturn n;&#125;</code></pre><p>11.插入一个结点</p><pre><code>bool ListInsert(LinkNode *&amp;L,int n,ElemType e)&#123;LinkNode *p=L,*s;int i=0;while(p!=NULL &amp;&amp; i&lt;n-1)&#123;    p=p-&gt;next;    i++;&#125;if(p==NULL || i&gt;n-1)return false;s = (LinkNode*)malloc(sizeof(LinkNode));s-&gt;data=e;s-&gt;next=p-&gt;next;p-&gt;next=s;return true;&#125;</code></pre><p>12.删除一个结点</p><pre><code>bool ListDelete(LinkNode *&amp;L,int n,ElemType &amp;e)&#123;    LinkNode *p = L, *q;    int i = 0;    while (p-&gt;next != NULL &amp;&amp; i &lt; n - 1)&#123;        p = p-&gt;next;        i++;    &#125;    if (p-&gt;next == NULL || i &gt; n - 1)        return false;    q = p-&gt;next;    e = q-&gt;data;    p-&gt;next = q-&gt;next;    free(q);    return true;&#125;</code></pre><p>13.main函数</p><pre><code>int main()&#123;LinkNode *L1,*L2,L;ElemType arr1[10]=&#123;2,4,6,8,10,12&#125;;ElemType arr2[10]=&#123;1,3,5,7,9,11&#125;;CreateListF(L1,arr1,6);printf(&quot;头插法L1：&quot;);DispList(L1);CreateListR(L2,arr2,6);printf(&quot;尾插法L2：&quot;);DispList(L2);L1-&gt;next=NULL;printf(&quot;L1清零后，是否为空：%d\n&quot;,ListEmpty(L1));printf(&quot;L2的长度：%d\n&quot;,ListLength(L2));int a,e,n=6;GetElem(L2,n,e);printf(&quot;得到L2的第%d个数e，e=%d\n&quot;,n,e);printf(&quot;L2的%d位于第%d个\n&quot;,e,LocateElem(L2,7));printf(&quot;插入333：&quot;);ListInsert(L2,5,333);DispList(L2);ListDelete(L2,6,a);printf(&quot;删除第6个数：&quot;);DispList(L2);return 0;&#125;</code></pre><hr><p>##双链表<br>1.结构体</p><pre><code>typedef int ElemType;typedef struct DNode&#123;    ElemType data;    struct DNode *prior;    struct DNode *next;&#125;DLinkNode;</code></pre><p>2.头插法创建链表</p><pre><code>void CreateListF(DLinkNode *&amp;L,ElemType a[],int n)&#123;L=(DLinkNode*)malloc(sizeof(DLinkNode));L-&gt;prior=NULL;L-&gt;next=NULL;for(int i=0;i&lt;n;i++)&#123;    DLinkNode *s=(DLinkNode*)malloc(sizeof(DLinkNode));    s-&gt;data=a[i];    s-&gt;next=L-&gt;next;    if(L-&gt;next!=NULL)        L-&gt;next-&gt;prior=s;    L-&gt;next=s;    s-&gt;prior=L;    &#125;&#125;</code></pre><p>3.尾插法创建链表</p><pre><code>void CreateListR(DLinkNode *&amp;L,ElemType a[],int n)&#123;L=(DLinkNode *)malloc(sizeof(DLinkNode));DLinkNode *r=L;for(int i=0;i&lt;n;i++)&#123;    DLinkNode *s=(DLinkNode *)malloc(sizeof(DLinkNode));    s-&gt;data=a[i];    r-&gt;next=s;    s-&gt;prior=L;    r=s;    &#125;r-&gt;next=NULL;&#125;</code></pre><p>4.双链表的插入</p><pre><code>bool ListInsert(DLinkNode *&amp;L,int n,ElemType e)&#123;DLinkNode *p=L;int i=0;while(p!=NULL || i&lt;n-1 )&#123;    p=p-&gt;next;    i++;&#125;if(p==NULL || i&gt;n-1)    return false;DLinkNode *s=(DLinkNode *)malloc(sizeof(DLinkNode));s-&gt;data=e;s-&gt;next=p-&gt;next;s-&gt;prior=p;if(p-&gt;next!=NULL)p-&gt;next-&gt;prior=s;p-&gt;next=s;return true;&#125;</code></pre><p>5.双链表的删除</p><pre><code>bool ListDelete(DLinkNode *&amp;L,int n,ElemType &amp;e)&#123;DLinkNode *p=L;int i=0;while(p!=NULL &amp;&amp; i&lt;n-1)&#123;    p=p-&gt;next;    i++;&#125;if(p==NULL || i&gt;n-1)    return false;DLinkNode *q=p-&gt;next;if(q-&gt;next!=NULL)q-&gt;next-&gt;prior=p;p-&gt;next=q-&gt;next;e=q-&gt;data;free(q);return true;&#125;</code></pre><p>6.链表的输出</p><pre><code>void DispList(DLinkNode *&amp;L)&#123;DLinkNode *p=L-&gt;next;while(p!=NULL)&#123;    printf(&quot;%d &quot;,p-&gt;data);    p=p-&gt;next;&#125;printf(&quot;\n&quot;);&#125;</code></pre><p>7.main函数</p><pre><code>int main()&#123;DLinkNode *L1,*L2;int arr1[10]=&#123;1,3,5,7,9,11&#125;;int arr2[10]=&#123;2,4,6,8,10,12&#125;;CreateListF(L1,arr1,6);CreateListR(L2,arr2,6);printf(&quot;L1：&quot;);DispList(L1);printf(&quot;L2：&quot;);DispList(L2);ListInsert(L1,2,222);int e;ListDelete(L2,3,e);printf(&quot;L1插入222：&quot;);DispList(L1);printf(&quot;L2删除第2个：&quot;);DispList(L2);return 0;&#125;</code></pre><hr><p>#顺序栈<br>0.头文件及宏定义</p><pre><code>#include &lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include &lt;iostream&gt;using namespace std;// 函数结果状态代码#define TRUE 1#define FALSE 0#define OK 1#define ERROR 0#define OVERFLOW -1 #define  STACK_INIT_SIZE   100  //存储空间初始分配量 #define  STACKINCREMENT    10   //存储空间分配增量  </code></pre><p>1.结构体</p><pre><code>typedef int SElemType;typedef struct&#123;SElemType *base;SElemType *top;int stacksize;&#125;SqStack;</code></pre><p>2.进栈</p><pre><code>void input (SElemType &amp;s)&#123;cin&gt;&gt;s;&#125;</code></pre><p>3.输出栈<br>该代码只能输出一个元素，即栈顶。</p><pre><code>void output(SElemType s)&#123;cout&lt;&lt;s&lt;&lt;&quot; &quot;;&#125;</code></pre><p>4.构造一个空栈</p><pre><code>void InitStack(SqStack &amp;S)&#123;S.base=(SElemType*)malloc(STACK_INIT_SIZE*sizeof(SElemType))if(!S.base) exit(OVERFOLW);S.top=S.base;S.stacksize=STACK_INIT_SIZE;&#125;</code></pre><p>5.销毁栈</p><pre><code>void DestroyStack(SqStack &amp;S)&#123;free(S.base);S.base=S.top=NULL;S.stacksize=0;&#125;</code></pre><p>6.清空栈</p><pre><code>void ClearStack(SqStack &amp;S)&#123;S.top=S.base;&#125;</code></pre><p>7.判断栈是否为空</p><pre><code>int StackEmpty(SqStack S)&#123;if(S.top==S.base)return TRUE;else return FLASE;&#125;</code></pre><p>8.返回栈的长度</p><pre><code>int StackLength(SqStack S)&#123;return S.top-S.base;&#125;</code></pre><p>9.获取栈顶元素</p><pre><code>int GetTop(SqStack S,SElemType &amp;e)&#123;if(S.top==S.base)return ERROR;e=*(S.top-1);return OK;&#125;</code></pre><p>10.插入新的栈顶元素e</p><pre><code>void Push(SqStack &amp;S,SElemType e)&#123;if(S.top-S.base&gt;=S.stacksize)&#123;S.base=(SElemType*)realloc(S.base,(S.stacksize+STACKINCREMENT)*sizeof(SElemType));if(!S.base)exit(OVERFLOW);S.top=S.base+S.stacksize;S.stacksize+=STACKINCREMENT;    &#125;*(S.top++)=e;&#125;</code></pre><p>11.删除并获得栈顶元素</p><pre><code>int Pop(SqStack &amp;S,SElemType &amp;e)&#123;if(S.top==S.base)return ERROR;e=*(--S.top);return OK;&#125;</code></pre><p>12.对栈的所有元素调用函数visit（）</p><pre><code>void StackTraverse(SqStack S,void(*visit)(SElemType))&#123;SElemType *p=S.base;while(p&lt;S.top)&#123;visit(*p);p++;    &#125;&#125;</code></pre><hr><p>#链栈<br>不带头节点的单链表<br>0.头文件,宏定义,函数声明</p><pre><code>#include &lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include &lt;iostream&gt;using namespace std;// // 函数结果状态代码 #define TRUE 1 #define FALSE 0 #define OK 1 #define ERROR 0typedef  int  SElemType;void input(SElemType &amp;s);void output(SElemType s);//typedef  SElemType  ElemType;   // 栈结点类型和链表结点类型一致//struct  LNode &#123;   ElemType data;   LNode *next; &#125;; typedef  LNode * LinkList; // 另一种定义LinkList的方法// 不带头结点的单链表的部分基本操作(9个)#define DestroyList ClearList // DestroyList()和ClearList()的操作是一样的 void InitList(LinkList &amp;L);  void ClearList(LinkList &amp;L); int ListEmpty(LinkList L); int ListLength(LinkList L); int GetElem(LinkList L,int i,ElemType &amp;e); int LocateElem(LinkList L,ElemType e,int(*compare)(ElemType,ElemType)); int ListInsert(LinkList &amp;L,int i,ElemType e); int ListDelete(LinkList &amp;L,int i,ElemType &amp;e); void ListTraverse(LinkList L,void(*vi)(ElemType)); /*****链栈的基本操作*****/typedef  LinkList LinkStack;     // LinkStack是指向栈结点的指针类型#define  InitStack  InitList     // InitStack()与InitList()作用相同，下同#define DestroyStack  DestroyList#define ClearStack  ClearList#define StackEmpty  ListEmpty#define StackLength ListLength//int GetTop(LinkStack S,SElemType &amp;e); // 若栈不空，则用e返回S的栈顶元素，并返回OK；否则返回ERRORint Push(LinkStack &amp;S,SElemType e);  // 插入元素e为新的栈顶元素int Pop(LinkStack &amp;S,SElemType &amp;e); // 若栈不空，则删除S的栈顶元素，用e返回其值，并返回OK；否则返回ERRORvoid StackTraverse(LinkStack S,void(*visit)(SElemType)); // 从栈底到栈顶依次对栈中每个元素调用函数visit()</code></pre><p>1.结构体</p><pre><code>typedef  int  SElemType;void input(SElemType &amp;s);void output(SElemType s);//typedef SElemType ElemType;struct LNode&#123;ElemType data;LNode *next;&#125;LinkList;</code></pre><p>2.输入输出元素</p><pre><code>void input(SElemType &amp;s)&#123;    cin&gt;&gt;s;&#125;//void output(SElemType s)&#123;    cout&lt;&lt;s&lt;&lt;&quot; &quot;;&#125;</code></pre><p>3.构造链表</p><pre><code>void InitList(LinkList &amp;L)&#123;L=NULL;&#125;</code></pre><p>4.清空链表</p><pre><code>void ClearList(LinkList &amp;L)&#123;LinkList p;while(L)&#123;p=L;L=L-&gt;next;free(p);    &#125;&#125;</code></pre><p>5.判断链表是否为空</p><pre><code>int ListEmpty(LinkList L)&#123;if(L)return FALSE;elsereturn TRUE;&#125;</code></pre><p>6.返回链长</p><pre><code>int ListLength(LinkList L)&#123;int i=0;LinkList p=L;while(p)&#123;p=p-&gt;next;i++;    &#125;return i;&#125;</code></pre><p>7.获得第i个元素赋值给e</p><pre><code>int GetElem(LinkList L,int i,ElemType &amp;e)&#123;int j=1;LinkList p=L;if(i&lt;1)return ERROR;while(j&lt;i &amp;&amp; p)&#123;j++;p=p-&gt;next;    &#125;if(j==i)&#123;e=p-&gt;data;return OK;    &#125;elsereturn ERROR;&#125;</code></pre><p>8.定位e元素的位置</p><pre><code>int LocateElem(LinkList L,Elemtype e,int(*compare)(ElemType,ElemType))&#123;int i=0;LinkList p=L;while(p)&#123;i++;if(compare(p-&gt;data,e))return i;p=p-&gt;next;    &#125;return 0;&#125;</code></pre><ol start="9"><li></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;img src=&quot;/2023/02/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/绪论.jpg&quot; width=&quot;200%&quot; height=&quot;200%&quot;&gt;
---
#线性表
##顺序表

&lt;p&gt;1.顺序表类型定</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>题目心得</title>
    <link href="http://example.com/2023/02/27/%E5%88%B7%E9%A2%98%E5%BF%83%E5%BE%97/"/>
    <id>http://example.com/2023/02/27/%E5%88%B7%E9%A2%98%E5%BF%83%E5%BE%97/</id>
    <published>2023-02-27T15:59:26.000Z</published>
    <updated>2023-03-17T05:21:16.964Z</updated>
    
    <content type="html"><![CDATA[<p><b>做题技巧</b></p><ul><li>1.在动手写代码之前，在草纸上尽可能地写好要实现的流程。</li><li>2.在代码中，尽量把每个部分模块化，写成函数、结构体或类。</li><li>3.对于一些可能重复用到的概念，可以统一转化，方便处理：如，某题给你 “YY-MM-DD 时：分” 把它抽取到一个函数，处理成秒，会减少概念混淆。</li><li>4.调试时分块调试。模块化的好处就是可以方便的单独调某一部分。</li><li>5.写代码的时候一定要思路清晰，不要想到什么写什么，要按照落在纸上的步骤写。</li></ul><hr><p><b>知识点</b></p><ul><li><p>1.字母大小写转化ASCII+-32</p></li><li><p>2.指针的变量的交换，正确的为：</p><p>  int temp,*p1,*p2;<br>  temp &#x3D; *p1;<br>  *p1 &#x3D; *p2;<br>  *p2 &#x3D; temp;</p></li></ul><p>错误的为：</p><pre><code>temp = p1;p1 = p2;p2 = temp;</code></pre><ul><li><ol start="3"><li><p>闰年的判断条件</p><p>if（(n%4 &#x3D;&#x3D; 0 &amp;&amp; n%100 !&#x3D; 0) || n %400 &#x3D;&#x3D; 0）{}</p></li></ol></li><li><ol start="4"><li></li></ol></li></ul><hr><p><b>详解</b></p><ul><li>1.数字反转<br>输入123.4<br>输出4.321</li></ul><p>…<br>float a,b&#x3D;0;<br>cin&gt;&gt;a;<br>int c&#x3D;a * 10;  &#x2F;&#x2F;使c变为整数<br>while(c){<br>    b&#x3D;b * 10+c%10;<br>    c&#x3D;c&#x2F;10;<br>}<br>cout&lt;&lt;b&#x2F;1000;<br>…</p><p>while循环<br>开始（1）c&#x3D;1234，b&#x3D;4，c&#x3D;123<br>（2）c&#x3D;123，b&#x3D;43，c&#x3D;12<br>（3）c&#x3D;12，b&#x3D;432，c&#x3D;1<br>（4）c&#x3D;1，b&#x3D;4321，c&#x3D;0<br>结束</p><ul><li>2.题目：母牛的故事：递归<br>打表理清思路先，把牛家分大牛、三岁牛宝、两岁牛宝、一岁牛宝（虚岁，出生就是一岁啦）</li></ul><img src="/2023/02/27/%E5%88%B7%E9%A2%98%E5%BF%83%E5%BE%97/刷题3.jpg" width="70%" height="70%"><p>在第5年时，牛宝开始陆续长成大牛，三岁牛宝就变成了大牛<br>同理，两岁牛宝变三岁牛宝，一岁牛宝变两岁牛宝<br>而新的一岁牛宝则是去年的大牛跟三岁牛宝的总牛数（三岁牛宝今年长成大牛也开始生小牛宝了）<br>思路理清后，就要求递推公式了，把4种牛分别用字母标记：<br>大牛a[]、三岁牛宝b[]、两岁牛宝c[]、一岁牛宝d[]以及牛头数s[]<br>可以得出第n年的各个公式：<br>a[n] &#x3D; a[n-1]+b[n-1]<br>b[n] &#x3D; c[n-1]<br>c[n] &#x3D; d[n-1]<br>d[n] &#x3D; a[n-1]+b[n-1] &#x3D; a[n]<br>则总牛数 s[n]&#x3D;a[n]+b[n]+c[n]+d[n]<br>    &#x3D; a[n-1]+b[n-1]+c[n-1]+d[n-1]+a[n-1]+b[n-1]<br>    &#x3D; s[n-1]+a[n-2]+b[n-2]+c[n-2]<br>    &#x3D; s[n-1]+a[n-3]+b[n-3]+c[n-3]+d[n-3]<br>    &#x3D; s[n-1]+s[n-3]</p><ul><li>3.最大公因数和最小公倍数求发<br>(1)辗转相除法<br>…<br>cin&gt;&gt;m&gt;&gt;n;<br>a &#x3D; m;<br>b &#x3D; n;<br>while (n !&#x3D;0 ){<br>  t &#x3D; m%n;<br>  m &#x3D; n;<br>  n &#x3D; t;<br>  }<br>max &#x3D; m；<br>min &#x3D; a * b&#x2F;max;<br>…<br>（2）暴力法<br>…<br>for(i &#x3D; 1;i&lt; &#x3D; n &amp;&amp; i&lt;&#x3D; m; ++i ){<br>  if(m%i &#x3D;&#x3D; 0 &amp;&amp; n%i &#x3D;&#x3D; 0)<br>  max&#x3D;i;<br>}<br>min &#x3D; m * n &#x2F; max;<br>…</li></ul><p><b>求解两个升序序列的中位数</b></p><pre><code>int Search_Mid(int A[], int B[], int n)&#123;        int *a = new int (2*n);   int j=0,k=0;   for(int i =0;i&lt;2*n;i++)&#123;        if(A[j]&lt;B[k]&amp;&amp;j&lt;n)&#123;  //从小到大A和B逐个赋给C             a[i]=A[j];            j++;        &#125;        else&#123;            a[i]=B[k];            k++;        &#125;    &#125;    return a[n-1];&#125;</code></pre><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;b&gt;做题技巧&lt;/b&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1.在动手写代码之前，在草纸上尽可能地写好要实现的流程。&lt;/li&gt;
&lt;li&gt;2.在代码中，尽量把每个部分模块化，写成函数、结构体或类。&lt;/li&gt;
&lt;li&gt;3.对于一些可能重复用到的概念，可以统一转化，方便处理：如，某题给你 </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>c语言概括</title>
    <link href="http://example.com/2023/02/25/c%E8%AF%AD%E8%A8%80%E6%A6%82%E6%8B%AC/"/>
    <id>http://example.com/2023/02/25/c%E8%AF%AD%E8%A8%80%E6%A6%82%E6%8B%AC/</id>
    <published>2023-02-24T16:28:21.000Z</published>
    <updated>2023-03-29T16:24:51.910Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>1.c语言有且只有一个main（）函数，且总是从main（）函数开始执行。</p></li><li><p>2.void在main（）函数前面，表示无返回值。</p></li><li><p>3.数据类型<br>（1）基本类型：整型，字符型，实型（浮点型）。</p></li></ul><p>（2）构造类型：数组类型，结构体类型，共用体类型，枚举类型。</p><p>（3）指针类型</p><p>（4）空类型</p><hr><p><b>常量</b></p><p>即执行中不改变的量，分为直接变量和符号常量。</p><ul><li>1.直接常量</li></ul><p>整型常量，实型常量，字符型常量，字符串常量。<br>（1）整型常量：正整数，负整数，零，可以用十进制，八进制，十六进制表示。</p><p>整型常数后加一个字母u或U，表示unsigned int型，如246U。</p><p>整型常数后加一个字母l或L，表示long int型，如12L。</p><p>（2）实型常量</p><p>实数又称浮点数，c语言中表示方式只有小数形式和指数形式两种。</p><p>小数形式：当整数部分或者小数部分为0时，可以省略不写，但是小数点不可省略。如12.345，3.，-.123等均为正确的实数。</p><p>指数形式：格式为：±尾数E指数。如1.23E-2，3.14E+3等。</p><p>注意：小数形式表示实数时，必须有小数点，并且前后必须有一边有数字。</p><p>小数形式表示实数时，E或者e前后必须有数字，指数部分只能时整数。</p><p>c语言中实型常量默认时double类型，如果在数字后面加上字母f或F，则认为时float类型。</p><p>（3）字符型常量</p><p>字符常量只能用单引号括起来，只能时单个字符。</p><p>c语言中的字符常量具有数字特征，参考ASCII表，大小写字母转化±32。</p><p>转义字符形式上多个字符组成，但它是一个字符常量，只代表一个字符。</p><p>（4）字符串常量</p><p>用双引号括起来的零个或多个字符序列，如”helloworld”。</p><p>在内存中末尾多一个’\0’字符表示结束。因此此字符常量占用内存12个，长度11。</p><p>注意：sizeof（）表示的是内存中的大小（字节数），它是关键字，不是函数。</p><p>strlen（）函数可以计算字符串的长度。</p><p>‘6’一个字符，”6”两个字符。</p><ul><li>2.符号常量：#define 标识符 常量值</li></ul><hr><p><b>变量</b><br>即程序运行期间可以变化的量。</p><ul><li>1.变量的定义与使用。</li></ul><p>类型说明符 变量名称；</p><p>类型说明符：int（整数型），float（单精度浮点型），double（双精度浮点型），char（字符型）。</p><p>类型与赋值不同是会自动转化，int直接省去小数部分。</p><ul><li>2.整型变量</li></ul><p>shout int（短整型），int(整型)，long int(长整型),unsigned short(无符号短整型),unsigned int(无符号整型),unsigned long（无符号整型），后三个只能是正数。</p><p>常用int</p><ul><li>3.实型变量</li></ul><p>float（单精度浮点型），double（双精度浮点型）</p><ul><li>4.字符型变量</li></ul><p>char（字符型）</p><hr><p><b>运算符和表达式</b><br>有+&#x3D;，-&#x3D;， * &#x3D;，&#x2F;&#x3D;，%&#x3D;等</p><ul><li>1.自增运算符和自减运算符：  ++  - -</li></ul><p>在变量前后有区别，例如</p><pre><code>i = 100;op1 = i++;  // op1 = 100，先 op1 = i，然后 i = i + 1i = 100;op2 = ++i;  // op2 = 101，先 i = i + 1，然后赋值 op2i = 100;op3 = i- -;  // op3 = 100，先赋值 op3，然后 i = i - 1i = 100;op4 = - -i;  // op4 = 99，先 i = i - 1，然后赋值 op4</code></pre><ul><li>2.注意优先级。<br>（1）一个整型数与一个浮点数进行计算时，他的返回结果是浮点型。<br>（2）两数相除是一定要注意数据类型，如5  *  6&#x2F;4与6&#x2F;4  *  5结果不同。<br>（3）8&#x2F;（8&#x2F;10）出错，应该改成8&#x2F;（8.0&#x2F;10）</li></ul><hr><p><b>数据类型的转换</b><br>不同类型的数据在一起运算时，会发生转换。</p><ul><li>1.自动转换：赋值运算符的右边的类型转换为左边的类型。</li><li>2.强制类型转换：（类型说明符）（表达式） 如：（float）（a+b）</li></ul><hr><p><b>分支结构</b></p><ul><li><p>1.条件运算符： ？<br>a？b：c  表示如果a成立，结果为b，否则为c。可以看作if-else理解</p><p>  int  a,b &#x3D; 1,c &#x3D; 2;<br>  if(a)<br>  b &#x3D; 1;<br>  else<br>  c &#x3D; 2;</p></li><li><p>2.逻辑运算符</p></li><li><p>3.（1）if-else<br>（2）switch</p><p>  switch(选择句){       &#x2F;&#x2F;选择句，标签都使用整型数据（可以为字母）<br>  caes 标签1 : {语句1}  &#x2F;&#x2F;使用break；停止，否则一直运行下去。<br>  case 标签2 : {语句2}<br>  default : {语句3}<br>  }</p></li></ul><hr><p><b>循环结构</b></p><ul><li><p>1.for循环</p><p>  for(初始值;循环条件;循环方式){<br>  循环体;<br>  }</p></li><li><p>2.while循环</p><p>  while（循环条件）{<br>  循环体；<br>  }</p></li></ul><ol start="3"><li>  do-while循环    &#x2F;&#x2F;与while循环相比先执行一次再判断循环条件<br>  do{<br>  循环体；<br>  }while（循环条件）；</li></ol><hr><p><b>数组</b><br>数组是线性关系，包括多维数组。</p><ul><li>1.数组大小固定，不能随意改变。</li><li>2.a[b],数组中的元素数量b一定是已知的常量。数组从a[0]开始到a[b-1]，共b个。</li><li>3.数组之间不能直接赋值。</li><li>4.多维数组：实质是数组的数组，通常使用for循环处理。</li><li>5.字符数组，用{‘ ’}进行初始化，初始个数大于数组个数，编程出错，小于则缺少的数组都是’\0’。</li><li>6.字符串数组，用{“ ”}进行初始化，最后一个数组一定时’\0’。</li><li>7.%s输出</li><li>8.字符串处理函数<br>（1）复制<br>strcpy（字符串1，字符串2）<br>字符串2复制给字符串1<br>（2）连接<br>strcat（字符串1，字符串2）<br>连接两个字符串。<br>（3）比较<br>strcmp（字符串1，字符串2）<br>字符串1&lt;字符串2，返回值&lt;0<br>字符串1&#x3D;字符串2，返回值&#x3D;0<br>字符串1&gt;字符串2，返回值&gt;0<br>(4)求长度<br>strlen（字符串）<br>（5）大写转换成小写<br>strlwr（字符串）<br>（6）小写转换成大写<br>strupr（字符串）</li></ul><hr><p><b>函数</b><br>标准函数，自定义函数，无参函数，有参函数</p><ul><li><p>1.标准函数，即已经定义好的函数，可直接调用。<br>主要包括数学函数，绝对值函数fabs（），平方根函数（）等，需要头文件声明。</p></li><li><p>2.自定义函数，自己定义，并调用。</p></li><li><p>3.无参函数即无参数，有参函数有参数。</p></li><li><p>4.无参函数的定义<br>类型名 函数名（）<br>{<br>函数体<br>}<br>或<br>类项名 函数名（void）<br>{<br>函数体<br>}</p></li><li><p>5.有参函数的定义<br>类项名 函数名（形参列表）<br>{<br>函数体<br>}</p></li><li><p>6.函数的调用<br>（1）无返回值的函数<br>函数名（实参列表）；<br>（2）有返回值的函数<br>x&#x3D;函数名（实参列表）；<br>（3）函数的嵌套<br>函数名（函数名（实参列表））；</p></li><li><p>7.函数的返回值<br>return 表达式；<br>return （表达式）；</p></li><li><p>8.递归函数<br>调用自己的函数，有直接递归调用，间接递归调用，如</p><p>  long fibo(int n)<br>  {int f;<br>  if(n&#x3D;&#x3D;1||n&#x3D;&#x3D;2)  &#x2F;&#x2F;递归结束条件<br>      f&#x3D;1;<br>  else<br>      f&#x3D;fibo(n-1)+fibo(n-2);&#x2F;&#x2F;递归调用<br>  return f;<br>  }</p></li><li><p>9.数组作函数的参数<br>（1）数组元素作为函数的参数，与普通函数使用相同。<br>（2）数组作为函数的参数。如<br>定义<br>void fun(int a[])  &#x2F;&#x2F;[]不能省略<br>{<br>函数体<br>}<br>调用</p><p>  int a[5]&#x3D;{1,2,3,4,5};<br>  fun(a);            &#x2F;&#x2F;[]必须省略</p></li></ul><hr><p><b>指针</b><br>指针就是某个对象（简单变量，数组，函数等）所占用的内存单元的首地址。</p><ul><li>1.指针变量的定义和初始化<br>（1）定义<br>类型名 * 指针变量名<br>说明：类型名是指针变量所指向对象的类型，* 在指针变量名前，用于区别其他变量， * 指针变量名就是指向对象的地址， * pa&#x3D;&amp;a。<br>（2）初始化<br>指针指向变量的初始化，如<br>指针变量名&#x3D;&amp;变量名；<br>int a&#x3D;67, * pa&#x3D;&amp;a；</li></ul><p>指针指向数组的初始化，如<br>指针变量名&#x3D;数组名；<br>int a[5], * p&#x3D;a;</p><p>使用指针变量初始化其他同类型指针变量<br>float a&#x3D;3.5, * pa, * pb;<br>pa&#x3D;&amp;a;<br>pb&#x3D;pa;</p><p>初始化也可为0或NULL<br>指针变量名&#x3D;0（NULL）</p><ul><li>2.指针变量的引用<br>int a&#x3D;5, * p;<br>p&#x3D;&amp;a；<br>&amp;表示取变量的地址， * 表示指向变量的地址，&amp;和 * 作用相反，因此 * （&amp;a）等价a。</li></ul><p>指针指向变量后，表达式可以混合运用直接和间接访问方式。在表达式中，若p指向a，则p与&amp;a等价，与 * p&#x3D;a等价。</p><ul><li>3.指针与函数<br>（1）指针作函数的参数，此函数可以改变变量的值，<br>形参格式为<br>数据类型名 函数名（类型名  * 指针名）  &#x2F;&#x2F; * 不能省略<br>{<br>函数体<br>}<br>（2）返回指针值的函数，表示调用该函数后返回一个指向某个类型的指针（地址）<br>在函数名前面加个 *<br>数据类型名  * 函数名（形参列表）<br>{<br>函数体<br>}<br>（3）指向函数的指针<br>类型名 （ * 指针变量名）（参数列表）；<br>int ( * pc)(int,int);<br>定义了指向函数的指针后，必须将一个函数名（函数的入口地址）赋给函数指针，然后才能调用函数。<br>int ( * pc)(int,int);<br>int ave(int a,int b);<br>pc&#x3D;ave;  &#x2F;&#x2F;指针pc指向函数ave<br>指针函数的指针调用函数的格式为<br>（ * 指针变量名）（实参列表）；<br>（ * pc）（a，b）；</li><li>4.指针与一维数组<br>（1）关系：数组中的元素按顺序存放在地址连续的内存单元中，每一个数组元素都有各自的地址，数组名是数组首元素的地址。如，<br>int a[5]&#x3D;{1,2,3,4,5}, * p;<br>p&#x3D;a;<br>或<br>int a[5]&#x3D;{1,2,3,4,5}, * p;<br>p&#x3D;&amp;a[0];<br>(2)运算<br>指针与正整数的加减结果是指针值，即地址。<br>(3)指针表达式</li></ul><ul><li>p++等价于 * （p++）</li><li>++p等价于 * （++p）<br>（ * p）++等价于a++   &#x2F;&#x2F; * p&#x3D;&amp;a<br>++ * p等价于++a</li></ul><ul><li>5.指针于二维数组<br>二维数组依然是顺序排列起来的。<br>二维数组名代表二维首元素（有多个首元素）的地址。<br>（1）指向二维数组元素的指针</li></ul><ul><li>指针变量名&#x3D;&amp;二维数组名[行下标][列下标]</li><li>指针变量名&#x3D; * 二维数组名</li><li>指针变量名&#x3D;二维数组名[行下标]<br>(2)指向二维数组行指针变量<br>类项名 （ * 指针变量名）[n]</li></ul><ul><li>6.指针与字符串<br>（1）字符串与字符指针<br>char   * str&#x3D;”hello”;<br>puts(str);<br>(2)使用字符数组与字符指针处理字符串的区别<br>赋值方法不同，系统为其分配内存单元的方式不同（字符数组不能直接输入，字符指针可以直接输入），修改值（地址）的方式不同。</li><li>7.二级指针与指针数组<br>（1）二级指针，即指针的指针。<br>类型名  *  * 变量名<br>int a, * pa&#x3D;&amp;a, *  * ppa&#x3D;&amp;pa;<br>(2)指针数组，把若干指针变量按有序的形式组织起来。<br>类项名  * 数组名[数组长度]</li></ul><hr><p><b>结构体与链表</b></p><ul><li>1.结构体<br>可以理解为自己定义的数据类型。<br>（1）定义（可以嵌套定义）</li></ul><p>struct 结构名{<br>  类型名 成员名1；<br>  类型名 成员名2；<br>…<br>  类型名  成员名 n；<br>}（变量名）；<br>或<br>struct 结构名{<br>  类型名 成员名1；<br>  类型名 成员名2；<br>…<br>  类型名  成员名 n；<br>}；<br>struct 结构名  变量名；&#x2F;&#x2F;两个位置的变量不可重复定义</p><p>（2）变量初始化（变量之间可以直接赋值或进行运算）<br>  变量名&#x3D;{初值表列}  &#x2F;&#x2F;根据结构体的成员元素类型和个数按顺序赋值，用“，”隔开，不能在结构体内赋初值。<br>（3）引用<br>结构变量名.成员名<br>（4）结构数组，赋初值时数组的每个元素（可用大括号括起来，方便查看）的每个成员不可忽略，不可跳过。<br>三种方式的引用<br>  结构数组名[下标].成员名<br> ( * (结构数组名+下标)).成员名<br> (结构数组名+下标)-&gt;成员名</p><ul><li>2.链表<br>（1）单链表<br>struct books<br>{int bno;<br>  char bname[20];<br>  struct books  * next;<br>};</li></ul><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;p&gt;1.c语言有且只有一个main（）函数，且总是从main（）函数开始执行。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;2.void在main（）函数前面，表示无返回值。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;3.数据类型&lt;br&gt;（1）基本类型：整型，字符型，实型（浮点</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>c with STL学习笔记</title>
    <link href="http://example.com/2023/02/24/c-with-STL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/2023/02/24/c-with-STL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2023-02-24T07:11:29.000Z</published>
    <updated>2023-03-18T17:11:56.868Z</updated>
    
    <content type="html"><![CDATA[<p>1.头文件：（1）万能头文件： #include&lt;bits&#x2F;stdc++.h&gt;<br>（2）加快c++中的输入输出：#define FIO ios::sync_with_stdio(0);cin.tie(0); &#x2F;&#x2F;不要忘记在main（）函数中写下：FIO;<br>（3）在c++中C语言程序加载库：#include &lt; cstdio &gt;<br>（4）#define 是一种预处理命令，用于定义宏，本质上是文本替换.<br>2.使用标准库空间std： using namespace std;<br>3.不要使用endl（复杂拖延时间），改用\n：(1)头文件替换： #define endl ‘\n’<br>（2）直接输出’\n’</p><hr><p><b>vector</b></p><pre><code>#include&lt;bits/stdc++.h&gt;  using namespace std;int main()&#123;            //初始化及遍历。     //vector&lt;int&gt; a(10,3);    //vector&lt;int&gt; a(b.begin(),b.begin+3);    int b[7]=&#123;1,2,3,4,5,6,7&#125;;    vector&lt;int&gt; a(b,b+7);    for(auto x:a)&#123;             cout&lt;&lt;x&lt;&lt;&quot; &quot;;    &#125;    cout&lt;&lt;endl;        //元素个数    int sum;    sum=a.size();         cout&lt;&lt;sum&lt;&lt;endl;        //将数组大小改为3    a.resize(3);          for(auto x:a)&#123;             cout&lt;&lt;x&lt;&lt;&quot; &quot;;    &#125;    cout&lt;&lt;endl;        //返回第一个和最后一个元素     int front=a.front();      int back=a.back();         cout&lt;&lt;front&lt;&lt;&quot; &quot;&lt;&lt;back&lt;&lt;endl;        //清空a的元素    a.clear();                //判断是否为空    int z=a.empty();      cout&lt;&lt;z&lt;&lt;endl;        //比较数组大小（从前往后比较）    vector&lt;int&gt; bala(4,3),bili(3,4);    cout&lt;&lt;&quot;bala:&quot;;    for(auto x:bala)&#123;             cout&lt;&lt;x&lt;&lt;&quot; &quot;;    &#125;    cout&lt;&lt;endl&lt;&lt;&quot;bili:&quot;;    for(auto x:bili)&#123;             cout&lt;&lt;x&lt;&lt;&quot; &quot;;    &#125;    cout&lt;&lt;endl;    if(bala&lt;bili)        cout&lt;&lt;&quot;bala&lt;bili&quot;&lt;&lt;endl;        //在数组尾部插入和删除元素     a.push_back(5);    a.push_back(6);    a.push_back(7);    a.push_back(8);    for(auto x:a)&#123;             cout&lt;&lt;x&lt;&lt;&quot; &quot;;    &#125;    cout&lt;&lt;endl;    a.pop_back();    for(auto x:a)&#123;             cout&lt;&lt;x&lt;&lt;&quot; &quot;;    &#125;    cout&lt;&lt;endl;        //a.begin();vector的第0个数    //a.end();vector的最后一个的数的后面一个数    //通常与for循环结合使用        //倒置    reverse(a.begin(),a.end());    for(auto x:a)&#123;             cout&lt;&lt;x&lt;&lt;&quot; &quot;;    &#125;        return 0;&#125;</code></pre><hr><p><b>pair</b></p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123;    //初始化    pair&lt;string,int&gt; p(&quot;hello&quot;,1);        //调用第一个，第二个    string a;    int b;    a=p.first;    b=p.second;    cout &lt;&lt; a &lt;&lt;&quot; &quot;&lt;&lt;b&lt;&lt; endl;        //嵌套    pair&lt;int,pair&lt;int,int&gt;&gt; q(2,&#123;1,3&#125;);    int d;    d=q.first;    cout &lt;&lt;d&lt;&lt; endl;        return 0;&#125;</code></pre><hr><p><b>string</b></p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123;    //初始化    string a= &quot;abc&quot;;    cout &lt;&lt; a &lt;&lt; endl;        //添加    a +=&#39;d&#39;;    cout &lt;&lt; a &lt;&lt; endl;        //输出    cout&lt;&lt;a.substr(0)&lt;&lt;endl;//原字符串    cout &lt;&lt;a.substr(1) &lt;&lt; endl;//除去第一个字符的原字符串    cout &lt;&lt;a.substr(0,10) &lt;&lt; endl;//输出0到10的字符串        //插入    a.push_back(&#39;e&#39;);//尾插入    a.insert(a.begin(),&#39;1&#39;);//在begin()插入     cout &lt;&lt; a&lt;&lt; endl;    string b=&quot;456&quot;;    a.insert(1,b,0,3);//在a的下标1字符处插入b的0到3的字符     cout &lt;&lt; a&lt;&lt; endl;        //判断    cout &lt;&lt;a.empty()&lt;&lt; endl;        //返回字母个数    cout&lt;&lt;a.size()&lt;&lt;&quot; &quot;&lt;&lt;a.length()&lt;&lt;endl;        //清空    a.clear();    cout&lt;&lt;a.empty()&lt;&lt;endl;        return 0;&#125;</code></pre><hr><p><b>stack栈 </b></p><pre><code>#include &lt;bits/stdc++.h&gt; using namespace std;int main()&#123;    stack&lt;int&gt; s;    s.push(3);    s.push(4);    s.push(5);    cout&lt;&lt;s.size()&lt;&lt;endl;    s.pop();     //弹出栈顶元素     cout&lt;&lt;s.top()&lt;&lt;endl;//返回栈顶元素     cout&lt;&lt;s.size()&lt;&lt;endl;    return 0;&#125;</code></pre><hr><p><b>deque双向队列</b></p><pre><code>#include &lt;bits/stdc++.h&gt; using namespace std;int main()&#123;    deque&lt;int&gt; ideq(20);//创建有n条数据的deque    deque&lt;int&gt;::iterator pos;    int i;    for(int i=0;i&lt;20;i++)    &#123;        ideq[i]=i;    &#125;    cout&lt;&lt;&quot;输出deque中的数据:&quot;;    for(int i=0;i&lt;20;i++)    &#123;        cout&lt;&lt;ideq[i]&lt;&lt;&quot; &quot;;    &#125;    cout&lt;&lt;endl;    //在头尾加入新的数据    ideq.push_back(50);    ideq.push_front(80);    cout&lt;&lt;&quot;输出deque中的数据:&quot;;    for(pos=ideq.begin();pos!=ideq.end();pos++)    &#123;        cout&lt;&lt;(*pos)&lt;&lt;&quot; &quot;;    &#125;cout&lt;&lt;endl;    //查找    int findx=15;    cout&lt;&lt;&quot;查找：&quot;&lt;&lt;findx&lt;&lt;endl;    pos=find(ideq.begin(),ideq.end(),findx);    if(pos!=ideq.end())        cout&lt;&lt;&quot;FIND &quot;&lt;&lt;(*pos)&lt;&lt;&quot; successfully&quot;&lt;&lt;endl;    else cout&lt;&lt;&quot;NOT FIND&quot;&lt;&lt;endl;    //在头尾删除数据    cout&lt;&lt;&quot;..在头尾删除数据..waiting.&quot;&lt;&lt;endl;    ideq.pop_back();//尾    ideq.pop_front();//头    cout&lt;&lt;endl;    cout&lt;&lt;&quot;请输出deque中的数据:&quot;;    for(pos=ideq.begin();pos!=ideq.end();pos++)    &#123;        cout&lt;&lt;(*pos)&lt;&lt;&quot; &quot;;    &#125;    cout&lt;&lt;endl;    return 0;&#125;</code></pre><hr><p><b>set 【集合】和 multiset</b><br>set不允许元素重复，如果有重复就会被忽略，但multiset允许.</p><pre><code>#include &lt;bits/stdc++.h&gt; using namespace std;int main()&#123;    set&lt;int&gt; s=&#123;1,2,3,4,5,6,7,9,8&#125;;        cout&lt;&lt;s.size()&lt;&lt;endl;// 返回元素个数        cout&lt;&lt;s.empty()&lt;&lt;endl; //返回set是否是空的        //s.clear(); //清空        s.begin(); //第0个数，支持++或--，返回前驱和后继        s.end(); //最后一个的数的后面一个数，支持++或--，返回前驱和后继        s.insert(8); //插入一个数        s.find(4); //查找一个数        cout&lt;&lt;s.count(5)&lt;&lt;endl; //返回某一个数的个数        s.erase(8); //删除所以x  时间复杂度 O(k + logn)        for(auto x:s)&#123;        cout&lt;&lt;x&lt;&lt;&#39; &#39;;        &#125;    s.erase(s.begin(),s.end());//删除一个迭代器        for(auto x:s)&#123;        cout&lt;&lt;x&lt;&lt;&#39; &#39;;        &#125;    return 0;&#125;</code></pre><hr><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;1.头文件：（1）万能头文件： #include&amp;lt;bits&amp;#x2F;stdc++.h&amp;gt;&lt;br&gt;（2）加快c++中的输入输出：#define FIO ios::sync_with_stdio(0);cin.tie(0); &amp;#x2F;&amp;#x2F;不要忘记在mai</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>c++课堂笔记</title>
    <link href="http://example.com/2023/02/22/c++%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/2023/02/22/c++%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/</id>
    <published>2023-02-21T16:24:50.000Z</published>
    <updated>2023-03-28T07:25:33.285Z</updated>
    
    <content type="html"><![CDATA[<p><b>第一课时</b></p><ul><li>1.c++语言的头文件扩展名是  .h<br>c++语言的源程序文件的扩展名是  .cpp</li><li>2.c++使用cin和cout进行输入输出必须包含的头文件是  iostream<br>c++语言程序中使用控制符setw进行格式输出时应包含的头文件是  iomanip</li><li>3.cin和cout为c++中预定义的对象。<br>  “&gt;&gt;”称为流插入运算符，执行输入功能。<br>  “&lt;&lt;”称为流输出运算符，执行输出功能。</li><li>4.const与dedine定义变量的区别：（1）const与dedine都可以在c++中定义变量。<br>（2）const要定义常量的类型，define则不需要。如：#define PI 3.1415926，const float PI&#x3D;3.1415926;<br>（3）define不分配内存，const在静态存储区中分配空间。</li><li>5.（1）endl相当于\n<br>（2）setw(int n)是c++中在输出操作中使用的字段宽度设置，设置输出的域宽，n表示字段宽度。只对紧接着的输出有效，紧接着的输出结束后又变回默认的域宽。<br>当后面紧跟着的输出字段长度小于n的时候，在该字段前面用空格补齐（默认为右对齐）；当输出字段长度大于n时，全部整体输出。<br>（3）setfill（‘$’）表示将代替空格填充为$。<br>（3）left左对齐，right右对齐，都对于整个语句有效。<br>（4）setprecision(int n)，表示输出浮点值n位有效数字，可以四舍五入，只对邻近的有效。<br>（5）fixed写在setprecision(int n)之前，将输出浮点值n位，改为浮点值小数点后的n位。</li><li>6.dec表示十进制，hex表示十六进制，oct表示八进制。</li></ul><hr><p><b>第二课时</b></p><p>预习</p><ul><li>1.函数原型<br>在c语言中，函数定义：函数类型 函数名（形参列表）{ 函数体 }<br>函数原型：函数类型 函数名（形参列表）；其也可称为为 函数类型：函数首部；<br>函数原型的作用：可以避免函数先调用后定义的错误，即当函数原型在函数调用前时，可以先调用后定义。</li><li>2.函数重载<br>overload直译为重载，为了方便理解，可意译为多态，即多种形态。因此函数重载理解为同一函数多种形态。<br>函数重载条件：函数名相同，参数类型或参数个数不同。与函数类型无关，判断时忽略。<br>例如void f1(int a);与void f1(double d);是函数重载。<br>int max(int a);与int max(int a,int b);是。<br>void f2(int a);与int f2(int a);不是.<br>一般用于相同类型的运算，但具体功能有些差别的函数。</li><li>3.作用域运算符 ::<br>当程序中外部变量与内部变量重名时，内部变量屏蔽外部变量。<br>如果将变量x前加::,即变为::x输出时，则可输出外部变量。</li></ul><p>上课内容</p><p>课堂代码</p><pre><code>#include&lt; iostream &gt;using namespace std;void area(int);void area(int,int);void area(int,int,int);int main()&#123;int r,a,b,x,y,h;cin&gt;&gt;r&gt;&gt;a&gt;&gt;b&gt;&gt;x&gt;&gt;y&gt;&gt;h;area(r);area(a,b);area(x,y,h);return 0;&#125;void area(int r)&#123;cout&lt;&lt;&quot;圆的面积是：&quot;&lt;&lt;r * r * 3.14&lt;&lt;endl;&#125;void area(int a,int b)&#123;cout&lt;&lt;&quot;长方形的面积是：&quot;&lt;&lt;a*b&lt;&lt;endl;&#125;void area(int x,int y,int h)&#123;cout&lt;&lt;&quot;梯形的面积是：&quot;&lt;&lt;(x+y)*h/2.0&lt;&lt;endl;&#125;</code></pre><p><b>第三课时</b></p><p>预习</p><ul><li><p>1.内置函数<br>又称内嵌函数，内联函数。其作用是使代码嵌入主调函数，省去函数调用的开销，即减少函数频繁调用消耗的时间，提高效率。<br>多用于频繁使用，且功能简单的函数。与普通函数相比，多出个inline，即<br>inline 函数类型 函数名 （形参列表）<br>  {函数体}</p></li><li><p>2.变量的引用<br>变量的引用就是变量的别名，因此引用又称别名。<br>引用的声明<br>数据类型 &amp;引用名&#x3D;已定义的变量名</p><p>  int a &#x3D; 10;<br>  int &amp;ra &#x3D; a;&#x2F;&#x2F;引用的数据类型必须与已定义的相同</p></li><li><p>3.引用传递<br>值传递</p><p>  void f(int a);</p></li></ul><p>地址传递</p><pre><code>void f(int *p);</code></pre><p>引用传递</p><pre><code>void f(int &amp;r);</code></pre><p>当引用作为函数的形参时，对应实参形参占用同一单元，形参与实参对应变化。</p><hr><p><b>第三课时</b></p><p>预习</p><ul><li><p>1.有默认参数的函数<br>即形式参数被赋予了一个数值<br>double area(double r&#x3D;2.5){…}  &#x2F;&#x2F;一个默认值<br>（1）和普通函数的区别<br>有默认参数的函数调用时有实参，就取实参的值；没有实参就取默认值。<br>因此有默认参数的函数调用可以不传递实参。<br>（2）两个默认参数的函数</p><p>  double area(double a&#x3D;2.5,double b){…}   &#x2F;&#x2F;语句错误<br>  double area(double a,double b&#x3D;2.3){…}<br>  double area(double a&#x3D;2.5,double b&#x3D;2.3){…}</p></li></ul><p>在给函数默认值赋值时，要从右向左依次赋值。<br>（3）在函数原型声明时赋默认值，定义中不再重复赋默认值。</p><ul><li>2.new和delete运算符<br>（1）作用<br>new：动态申请内存空间<br>delete：释放new申请的内存空间</li></ul><p>注意：动态：程序运行时；静态：编译时。</p><p>（2）使用方法<br>1）申请单个存储单元<br>指针变量名&#x3D;new 数据类型</p><pre><code>int  * p = new int（10）；   //申请一个存储单元用来存放int型数据（10）</code></pre><p>释放存储单元：delete 指针变量名；<br>delete p；</p><p>2）申请数组存储空间<br>指针变量名 &#x3D; new 数据类型[整型表达式]；</p><pre><code>int *p = new int[10];  //申请一块存储空间用来存放10个int型数据* (p + 2) = 15;</code></pre><p>释放存储单元：delete []指针变量名；<br>delete []p；</p><hr><p><b>第四课时</b></p><ul><li><p>1.类的声明<br>(1)</p><p>  class 类名<br>  {<br>   访问权限 数据和函数；<br>  }</p></li></ul><p>标准代码</p><pre><code>class Student&#123;public :    void display();//公用成员函数原型声明private :    int num;string name; char sex;//私有数据成员&#125;;void Student∷ display()//在类外定义display类函数&#123;    cout&lt;&lt;″num:″&lt;&lt;num&lt;&lt;endl;    cout&lt;&lt;″name:″&lt;&lt;name&lt;&lt;endl;    cout&lt;&lt;″sex:″&lt;&lt;sex&lt;&lt;endl;&#125;Student stud1,stud2;//定义两个类对象</code></pre><hr><p><b>第五课时</b></p><ul><li><p>1.构造函数<br>（1）构造函数的作业<br>在定义对象时给对象分配内存空间，并初始化对象的数据成员。</p><p>  Date d1,d2;<br>  d1.init(2021,9,10);<br>  d2.init(2021,10,1);</p></li></ul><p>（2）构造函数的特征<br>函数名与类名相同<br>没有返回值类型<br>定义对象时由系统自动调用</p><ul><li><p>2.析构函数<br>（1）作用<br>在撤销对象占用的内存之前完成一些清理工作，使这部分内存可以被程序分配给新对象使用<br>（2）特征<br>函数名与类名相同，在函数名前加~<br>没有返回值类型<br>没有形式参数<br>撤销对象前系统自动调用，也可以由用户调用</p><p>  class Data<br>  {<br>  ……<br>  public:<br>    Date(int y,int m,int d);<br>    ~Date();<br>  };</p><p>  Date::~Date()<br>  {……}</p></li><li><p>3.构造函数和析构函数的调用顺序<br>先构造的后析构，后构造的先析构</p></li></ul><hr><p><b>第六课时</b><br>1.拷贝构造函数<br>（1）作用<br>在建立对象时，用已经存在的对象初始化该对象。</p><pre><code>Date d1(2021,7,21);Date d2(d1);//构造函数的两种方法Date d3=d1;Date d4; d4=d1;//此处不能构造，没有在建立对象时构造。</code></pre><p>（2）形式<br>类名::类名（类名 &amp;对象名）<br>{  函数体}</p><pre><code>Date::Date (Date &amp;rd)&#123; year=rd.year;  month=rd.month;  day=rd.day;&#125; </code></pre><p>2.this指针<br>this指针是系统提供，不需要用户定义；<br>this指向正在进行成员函数调用的对象；</p><ol start="3"><li><p>静态成员<br>即所有对象所共享的数据<br>（1）静态成员数据</p><p> static 数据类型 数据成员名；<br> class Student<br> {<br> public:<br> int xh,score;<br> static int sum;<br> …<br> }s1;</p></li></ol><p>特征：①对象共享静态数据成员<br>②类体外初始化，不能通过参数初始化表初始化</p><pre><code>int Student::count =0;//正确形式Student(int x,int sc,int su):xh(x),score(sc),sum(su)&#123;&#125;  //错误形式</code></pre><p>③对象名或类名引用静态数据成员</p><pre><code>s1.sum=10;//或者Student::sum=10;</code></pre><p>（2）静态成员函数 </p><pre><code>static 函数类型 函数名（参数）&#123; 函数体 &#125;class Student&#123;private:    int xh,score;    static int sum;public:static void printSum()    &#123;cout&lt;&lt;&quot;总分:&quot;&lt;&lt;sum&lt;&lt;endl;&#125;&#125;；</code></pre><p>特征：①对象共享静态成员函数<br>②对象名或类名引用静态数据成员<br>s1.printfSum();<br>Student::printSum();<br>③静态成员函数没有this指针<br>④不能访问类中非静态成员数据</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;b&gt;第一课时&lt;/b&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1.c++语言的头文件扩展名是  .h&lt;br&gt;c++语言的源程序文件的扩展名是  .cpp&lt;/li&gt;
&lt;li&gt;2.c++使用cin和cout进行输入输出必须包含的头文件是  iostream&lt;br&gt;c++语言程序中使用控制符</summary>
      
    
    
    
    
  </entry>
  
</feed>
