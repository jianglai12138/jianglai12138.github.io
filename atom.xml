<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Welcome to my blog</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-03-03T00:48:52.831Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>不秃头战士</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数据结构笔记</title>
    <link href="http://example.com/2023/02/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/2023/02/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/</id>
    <published>2023-02-28T12:28:51.000Z</published>
    <updated>2023-03-03T00:48:52.831Z</updated>
    
    <content type="html"><![CDATA[<p><b>数据结构的定义</b><br>数据项，数据对象，数据结构（逻辑结构，存储结构，数据的运算）</p><p>逻辑结构（1）表示：（1）图表表示 （2）二元组表示 B&#x3D;（D，R）<br>（2）类型：集合，线性结构，树形结构，图形结构</p><p>存储类型：顺序存储结构，链式存储结构，索引存储结构，哈希存储结构</p><p><b>数据结构的类型</b></p><p>数据类型：（1）c++语言中常用的数据类型（2）存储空间的分配，抽象数据类型</p><hr><p><b>顺序表的9种操作</b></p><ul><li>1.LinList(&amp;L)<br>构造一个空的线性表L</li><li>2.DestroyList（&amp;L）<br>销毁线性表L</li><li>3.ClearList（&amp;L）<br>将线性表L重置为空表</li><li>4.ListEmpty（L）<br>若线性表为空表，则返回ture，否则返回false。</li><li>5.Listength（L）<br>返回线性表L中的数据元素个数</li><li>6.GetElem（L，i，&amp;e）；<br>用e返回线性表L中第i个数据元素的值<br>前提：1 &lt;&#x3D; i &lt;&#x3D; ListLength(L)</li><li>7.LocateElem(L,e,compare())<br>返回L中第1个与e满足compare（）的数据元素的位序，若不存在返回0。<br>前提：compare（）是数据元素判定函数。</li><li>8.PriorElem(L,cur_e,&amp;pre_e)<br>若cur_e是L数据元素，且不是第一个。则用pre_e返回它的前驱，否则无意义。</li><li>9.NextElem（L，cur_e,&amp;next_e）<br>若cur_e是L的数据元素，且不是最后一个，则用next_e返回它的后继，否则操作失败,next_e无意义。</li><li>10..Listlnsert(&amp;L,i,e)<br>在L的第i个位置之前插入新的数据元素e,L的长度加一。</li><li>11.ListDelete(&amp;L,i,&amp;e)<br>删除前（长度为n ) :<br>( a1,a2…,ai-1,ai, ai+1,..,an)<br>删除后（长度为n -1 ) :<br>(a1,a2,…,ai-1,ai+1,…,an)<br>操作结果:删除L的第i个数据元素，并用e返回其值,L的长度减一。</li><li>12.ListTraverse(&amp;L, visited())<br>依次对线性表中每个元素调用visited()</li></ul><p>注意：这些运算都是在线性表L已经存在的情况下进行的。</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;b&gt;数据结构的定义&lt;/b&gt;&lt;br&gt;数据项，数据对象，数据结构（逻辑结构，存储结构，数据的运算）&lt;/p&gt;
&lt;p&gt;逻辑结构（1）表示：（1）图表表示 （2）二元组表示 B&amp;#x3D;（D，R）&lt;br&gt;（2）类型：集合，线性结构，树形结构，图形结构&lt;/p&gt;
&lt;p&gt;存储类型：顺序</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>题目心得</title>
    <link href="http://example.com/2023/02/27/%E5%88%B7%E9%A2%98%E5%BF%83%E5%BE%97/"/>
    <id>http://example.com/2023/02/27/%E5%88%B7%E9%A2%98%E5%BF%83%E5%BE%97/</id>
    <published>2023-02-27T15:59:26.000Z</published>
    <updated>2023-03-03T01:07:23.849Z</updated>
    
    <content type="html"><![CDATA[<ul><li>1.字母大小写转化ASCII+-32</li><li>2.数字反转<br>输入123.4<br>输出4.321</li></ul><p>…<br>float a,b&#x3D;0;<br>cin&gt;&gt;a;<br>int c&#x3D;a * 10;  &#x2F;&#x2F;使c变为整数<br>while(c){<br>    b&#x3D;b * 10+c%10;<br>    c&#x3D;c&#x2F;10;<br>}<br>cout&lt;&lt;b&#x2F;1000;<br>…</p><p>while循环<br>开始（1）c&#x3D;1234，b&#x3D;4，c&#x3D;123<br>（2）c&#x3D;123，b&#x3D;43，c&#x3D;12<br>（3）c&#x3D;12，b&#x3D;432，c&#x3D;1<br>（4）c&#x3D;1，b&#x3D;4321，c&#x3D;0<br>结束</p><ul><li><ol start="3"><li>打表理清思路先，把牛家分大牛、三岁牛宝、两岁牛宝、一岁牛宝（虚岁，出生就是一岁啦）</li></ol></li></ul><p><img src="/2023/02/27/%E5%88%B7%E9%A2%98%E5%BF%83%E5%BE%97/%E5%88%B7%E9%A2%983.jpg" alt="图片1"></p><p>在第5年时，牛宝开始陆续长成大牛，三岁牛宝就变成了大牛<br>同理，两岁牛宝变三岁牛宝，一岁牛宝变两岁牛宝<br>而新的一岁牛宝则是去年的大牛跟三岁牛宝的总牛数（三岁牛宝今年长成大牛也开始生小牛宝了）<br>思路理清后，就要求递推公式了，把4种牛分别用字母标记：<br>大牛a[]、三岁牛宝b[]、两岁牛宝c[]、一岁牛宝d[]以及牛头数s[]<br>可以得出第n年的各个公式：<br>a[n] &#x3D; a[n-1]+b[n-1]<br>b[n] &#x3D; c[n-1]<br>c[n] &#x3D; d[n-1]<br>d[n] &#x3D; a[n-1]+b[n-1] &#x3D; a[n]<br>则总牛数 s[n]&#x3D;a[n]+b[n]+c[n]+d[n]<br>    &#x3D; a[n-1]+b[n-1]+c[n-1]+d[n-1]+a[n-1]+b[n-1]<br>    &#x3D; s[n-1]+a[n-2]+b[n-2]+c[n-2]<br>    &#x3D; s[n-1]+a[n-3]+b[n-3]+c[n-3]+d[n-3]<br>    &#x3D; s[n-1]+s[n-3]</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;1.字母大小写转化ASCII+-32&lt;/li&gt;
&lt;li&gt;2.数字反转&lt;br&gt;输入123.4&lt;br&gt;输出4.321&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;…&lt;br&gt;float a,b&amp;#x3D;0;&lt;br&gt;cin&amp;gt;&amp;gt;a;&lt;br&gt;int c&amp;#x3D;a * 10</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>c语言概括</title>
    <link href="http://example.com/2023/02/25/c%E8%AF%AD%E8%A8%80%E6%A6%82%E6%8B%AC/"/>
    <id>http://example.com/2023/02/25/c%E8%AF%AD%E8%A8%80%E6%A6%82%E6%8B%AC/</id>
    <published>2023-02-24T16:28:21.000Z</published>
    <updated>2023-03-02T05:21:25.660Z</updated>
    
    <content type="html"><![CDATA[<ul><li>1.c语言有且只有一个main（）函数，且总是从main（）函数开始执行。</li><li>2.void在main（）函数前面，表示无返回值。</li><li>3.数据类型<br>（1）基本类型：整型，字符型，实型（浮点型）。<br>（2）构造类型：数组类型，结构体类型，共用体类型，枚举类型。<br>（3）指针类型<br>（4）空类型</li></ul><hr><p><b>常量</b><br>即执行中不改变的量，分为直接变量和符号常量。</p><ul><li>1.直接常量<br>整型常量，实型常量，字符型常量，字符串常量。<br>（1）整型常量：正整数，负整数，零，可以用十进制，八进制，十六进制表示。<br>整型常数后加一个字母u或U，表示unsigned int型，如246U。<br>整型常数后加一个字母l或L，表示long int型，如12L。<br>（2）实型常量<br>实数又称浮点数，c语言中表示方式只有小数形式和指数形式两种。<br>小数形式：当整数部分或者小数部分为0时，可以省略不写，但是小数点不可省略。如12.345，3.，-.123等均为正确的实数。<br>指数形式：格式为：±尾数E指数。如1.23E-2，3.14E+3等。<br>注意：小数形式表示实数时，必须有小数点，并且前后必须有一边有数字。<br>小数形式表示实数时，E或者e前后必须有数字，指数部分只能时整数。<br>c语言中实型常量默认时double类型，如果在数字后面加上字母f或F，则认为时float类型。<br>（3）字符型常量<br>字符常量只能用单引号括起来，只能时单个字符。<br>c语言中的字符常量具有数字特征，参考ASCII表，大小写字母转化±32。<br>转义字符形式上多个字符组成，但它是一个字符常量，只代表一个字符。<br>（4）字符串常量<br>用双引号括起来的零个或多个字符序列，如”helloworld”。<br>在内存中末尾多一个’\0’字符表示结束。因此此字符常量占用内存12个，长度11。<br>注意：sizeof（）表示的是内存中的大小（字节数），它是关键字，不是函数。<br>strlen（）函数可以计算字符串的长度。<br>‘6’一个字符，”6”两个字符。</li><li>2.符号常量：#define 标识符 常量值</li></ul><hr><p><b>变量</b><br>即程序运行期间可以变化的量。</p><ul><li>1.变量的定义与使用。<br>类型说明符 变量名称；<br>类型说明符：int（整数型），float（单精度浮点型），double（双精度浮点型），char（字符型）。<br>类型与赋值不同是会自动转化，int直接省去小数部分。</li><li>2.整型变量<br>shout int（短整型），int(整型)，long int(长整型),unsigned short(无符号短整型),unsigned int(无符号整型),unsigned long（无符号整型），后三个只能是正数。<br>常用int</li><li>3.实型变量<br>float（单精度浮点型），double（双精度浮点型）</li><li>4.字符型变量<br>char（字符型）</li></ul><hr><p><b>运算符和表达式</b><br>有+&#x3D;，-&#x3D;， * &#x3D;，&#x2F;&#x3D;，%&#x3D;等</p><ul><li>1.自增运算符和自减运算符：  ++  - -<br>在变量前后有区别，例如<br>i &#x3D; 100;<br>op1 &#x3D; i++;  &#x2F;&#x2F; op1 &#x3D; 100，先 op1 &#x3D; i，然后 i &#x3D; i + 1<br>i &#x3D; 100;<br>op2 &#x3D; ++i;  &#x2F;&#x2F; op2 &#x3D; 101，先 i &#x3D; i + 1，然后赋值 op2<br>i &#x3D; 100;<br>op3 &#x3D; i- -;  &#x2F;&#x2F; op3 &#x3D; 100，先赋值 op3，然后 i &#x3D; i - 1<br>i &#x3D; 100;<br>op4 &#x3D; - -i;  &#x2F;&#x2F; op4 &#x3D; 99，先 i &#x3D; i - 1，然后赋值 op4</li><li>2.注意优先级。<br>（1）一个整型数与一个浮点数进行计算时，他的返回结果是浮点型。<br>（2）两数相除是一定要注意数据类型，如5  *  6&#x2F;4与6&#x2F;4  *  5结果不同。<br>（3）8&#x2F;（8&#x2F;10）出错，应该改成8&#x2F;（8.0&#x2F;10）</li></ul><hr><p><b>数据类型的转换</b><br>不同类型的数据在一起运算时，会发生转换。</p><ul><li>1.自动转换：赋值运算符的右边的类型转换为左边的类型。</li><li>2.强制类型转换：（类型说明符）（表达式） 如：（float）（a+b）</li></ul><hr><p><b>分支结构</b></p><ul><li>1.条件运算符： ？<br>a？b：c  表示如果a成立，结果为b，否则为c。可以看作if-else理解<br>int  a,b &#x3D; 1,c &#x3D; 2;<br>if(a)<br>b &#x3D; 1;<br>else<br>c &#x3D; 2;</li><li>2.逻辑运算符</li><li>3.（1）if-else<br>（2）switch<br>switch(选择句){       &#x2F;&#x2F;选择句，标签都使用整型数据（可以为字母）<br>caes 标签1 : {语句1}  &#x2F;&#x2F;使用break；停止，否则一直运行下去。<br>case 标签2 : {语句2}<br>default : {语句3}<br>}</li></ul><hr><p><b>循环结构</b></p><ul><li>1.for循环<br>for(初始值;循环条件;循环方式){<br>循环体;<br>}</li><li>2.while循环<br>while（循环条件）{<br>循环体；<br>}</li><li>3.do-while循环    &#x2F;&#x2F;与while循环相比先执行一次再判断循环条件<br>do{<br>循环体；<br>}while（循环条件）；</li></ul><hr><p><b>数组</b><br>数组是线性关系，包括多维数组。</p><ul><li>1.数组大小固定，不能随意改变。</li><li>2.a[b],数组中的元素数量b一定是已知的常量。数组从a[0]开始到a[b-1]，共b个。</li><li>3.数组之间不能直接赋值。</li><li>4.多维数组：实质是数组的数组，通常使用for循环处理。</li><li>5.字符数组，用{‘ ’}进行初始化，初始个数大于数组个数，编程出错，小于则缺少的数组都是’\0’。</li><li>6.字符串数组，用{“ ”}进行初始化，最后一个数组一定时’\0’。</li><li>7.%s输出</li><li>8.字符串处理函数<br>（1）复制<br>strcpy（字符串1，字符串2）<br>字符串2复制给字符串1<br>（2）连接<br>strcat（字符串1，字符串2）<br>连接两个字符串。<br>（3）比较<br>strcmp（字符串1，字符串2）<br>字符串1&lt;字符串2，返回值&lt;0<br>字符串1&#x3D;字符串2，返回值&#x3D;0<br>字符串1&gt;字符串2，返回值&gt;0<br>(4)求长度<br>strlen（字符串）<br>（5）大写转换成小写<br>strlwr（字符串）<br>（6）小写转换成大写<br>strupr（字符串）</li></ul><hr><p><b>函数</b><br>标准函数，自定义函数，无参函数，有参函数</p><ul><li>1.标准函数，即已经定义好的函数，可直接调用。<br>主要包括数学函数，绝对值函数fabs（），平方根函数（）等，需要头文件声明。</li><li>2.自定义函数，自己定义，并调用。</li><li>3.无参函数即无参数，有参函数有参数。</li><li>4.无参函数的定义<br>类型名 函数名（）<br>{<br>函数体<br>}<br>或<br>类项名 函数名（void）<br>{<br>函数体<br>}</li><li>5.有参函数的定义<br>类项名 函数名（形参列表）<br>{<br>函数体<br>}</li><li>6.函数的调用<br>（1）无返回值的函数<br>函数名（实参列表）；<br>（2）有返回值的函数<br>x&#x3D;函数名（实参列表）；<br>（3）函数的嵌套<br>函数名（函数名（实参列表））；</li><li>7.函数的返回值<br>return 表达式；<br>return （表达式）；</li><li>8.递归函数<br>调用自己的函数，有直接递归调用，间接递归调用，如<br>long fibo(int n)<br>{int f;<br>  if(n&#x3D;&#x3D;1||n&#x3D;&#x3D;2)  &#x2F;&#x2F;递归结束条件<br>  f&#x3D;1;<br>  else<br>  f&#x3D;fibo(n-1)+fibo(n-2);&#x2F;&#x2F;递归调用<br>  return f;<br>}</li><li>9.数组作函数的参数<br>（1）数组元素作为函数的参数，与普通函数使用相同。<br>（2）数组作为函数的参数。如<br>定义<br>void fun(int a[])  &#x2F;&#x2F;[]不能省略<br>{<br>函数体<br>}<br>调用<br>int a[5]&#x3D;{1,2,3,4,5};<br>fun(a);            &#x2F;&#x2F;[]必须省略</li></ul><hr><p><b>指针</b><br>指针就是某个对象（简单变量，数组，函数等）所占用的内存单元的首地址。</p><ul><li>1.指针变量的定义和初始化<br>（1）定义<br>类型名 * 指针变量名<br>说明：类型名是指针变量所指向对象的类型，* 在指针变量名前，用于区别其他变量， * 指针变量名就是指向对象的地址， * pa&#x3D;&amp;a。<br>（2）初始化<br>指针指向变量的初始化，如<br>指针变量名&#x3D;&amp;变量名；<br>int a&#x3D;67, * pa&#x3D;&amp;a；</li></ul><p>指针指向数组的初始化，如<br>指针变量名&#x3D;数组名；<br>int a[5], * p&#x3D;a;</p><p>使用指针变量初始化其他同类型指针变量<br>float a&#x3D;3.5, * pa, * pb;<br>pa&#x3D;&amp;a;<br>pb&#x3D;pa;</p><p>初始化也可为0或NULL<br>指针变量名&#x3D;0（NULL）</p><ul><li>2.指针变量的引用<br>int a&#x3D;5, * p;<br>p&#x3D;&amp;a；<br>&amp;表示取变量的地址， * 表示指向变量的地址，&amp;和 * 作用相反，因此 * （&amp;a）等价a。</li></ul><p>指针指向变量后，表达式可以混合运用直接和间接访问方式。在表达式中，若p指向a，则p与&amp;a等价，与 * p&#x3D;a等价。</p><ul><li>3.指针与函数<br>（1）指针作函数的参数，此函数可以改变变量的值，<br>形参格式为<br>数据类型名 函数名（类型名  * 指针名）  &#x2F;&#x2F; * 不能省略<br>{<br>函数体<br>}<br>（2）返回指针值的函数，表示调用该函数后返回一个指向某个类型的指针（地址）<br>在函数名前面加个 *<br>数据类型名  * 函数名（形参列表）<br>{<br>函数体<br>}<br>（3）指向函数的指针<br>类型名 （ * 指针变量名）（参数列表）；<br>int ( * pc)(int,int);<br>定义了指向函数的指针后，必须将一个函数名（函数的入口地址）赋给函数指针，然后才能调用函数。<br>int ( * pc)(int,int);<br>int ave(int a,int b);<br>pc&#x3D;ave;  &#x2F;&#x2F;指针pc指向函数ave<br>指针函数的指针调用函数的格式为<br>（ * 指针变量名）（实参列表）；<br>（ * pc）（a，b）；</li><li>4.指针与一维数组<br>（1）关系：数组中的元素按顺序存放在地址连续的内存单元中，每一个数组元素都有各自的地址，数组名是数组首元素的地址。如，<br>int a[5]&#x3D;{1,2,3,4,5}, * p;<br>p&#x3D;a;<br>或<br>int a[5]&#x3D;{1,2,3,4,5}, * p;<br>p&#x3D;&amp;a[0];<br>(2)运算<br>指针与正整数的加减结果是指针值，即地址。<br>(3)指针表达式</li></ul><ul><li>p++等价于 * （p++）</li><li>++p等价于 * （++p）<br>（ * p）++等价于a++   &#x2F;&#x2F; * p&#x3D;&amp;a<br>++ * p等价于++a</li></ul><ul><li>5.指针于二维数组<br>二维数组依然是顺序排列起来的。<br>二维数组名代表二维首元素（有多个首元素）的地址。<br>（1）指向二维数组元素的指针</li></ul><ul><li>指针变量名&#x3D;&amp;二维数组名[行下标][列下标]</li><li>指针变量名&#x3D; * 二维数组名</li><li>指针变量名&#x3D;二维数组名[行下标]<br>(2)指向二维数组行指针变量<br>类项名 （ * 指针变量名）[n]</li></ul><ul><li>6.指针与字符串<br>（1）字符串与字符指针<br>char   * str&#x3D;”hello”;<br>puts(str);<br>(2)使用字符数组与字符指针处理字符串的区别<br>赋值方法不同，系统为其分配内存单元的方式不同（字符数组不能直接输入，字符指针可以直接输入），修改值（地址）的方式不同。</li><li>7.二级指针与指针数组<br>（1）二级指针，即指针的指针。<br>类型名  *  * 变量名<br>int a, * pa&#x3D;&amp;a, *  * ppa&#x3D;&amp;pa;<br>(2)指针数组，把若干指针变量按有序的形式组织起来。<br>类项名  * 数组名[数组长度]</li></ul><hr><p><b>结构体与链表</b></p><ul><li>1.结构体<br>可以理解为自己定义的数据类型。<br>（1）定义（可以嵌套定义）</li></ul><p>struct 结构名{<br>  类型名 成员名1；<br>  类型名 成员名2；<br>…<br>  类型名  成员名 n；<br>}（变量名）；<br>或<br>struct 结构名{<br>  类型名 成员名1；<br>  类型名 成员名2；<br>…<br>  类型名  成员名 n；<br>}；<br>struct 结构名  变量名；&#x2F;&#x2F;两个位置的变量不可重复定义</p><p>（2）变量初始化（变量之间可以直接赋值或进行运算）<br>  变量名&#x3D;{初值表列}  &#x2F;&#x2F;根据结构体的成员元素类型和个数按顺序赋值，用“，”隔开，不能在结构体内赋初值。<br>（3）引用<br>结构变量名.成员名<br>（4）结构数组，赋初值时数组的每个元素（可用大括号括起来，方便查看）的每个成员不可忽略，不可跳过。<br>三种方式的引用<br>  结构数组名[下标].成员名<br> ( * (结构数组名+下标)).成员名<br> (结构数组名+下标)-&gt;成员名</p><ul><li>2.链表<br>（1）单链表<br>struct books<br>{int bno;<br>  char bname[20];<br>  struct books  * next;<br>};</li></ul><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;1.c语言有且只有一个main（）函数，且总是从main（）函数开始执行。&lt;/li&gt;
&lt;li&gt;2.void在main（）函数前面，表示无返回值。&lt;/li&gt;
&lt;li&gt;3.数据类型&lt;br&gt;（1）基本类型：整型，字符型，实型（浮点型）。&lt;br&gt;（2）构造类型：数组类型</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>c with STL学习笔记</title>
    <link href="http://example.com/2023/02/24/c-with-STL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/2023/02/24/c-with-STL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2023-02-24T07:11:29.000Z</published>
    <updated>2023-02-28T06:32:09.936Z</updated>
    
    <content type="html"><![CDATA[<p>1.头文件：（1）万能头文件： #include&lt;bits&#x2F;stdc++.h&gt;<br>（2）加快c++中的输入输出：#define FIO ios::sync_with_stdio(0);cin.tie(0); &#x2F;&#x2F;不要忘记在main（）函数中写下：FIO;<br>（3）在c++中C语言程序加载库：#include <cstdio><br>（4）#define 是一种预处理命令，用于定义宏，本质上是文本替换.<br>2.使用标准库空间std： using namespace std;<br>3.不要使用endl（复杂拖延时间），改用\n：(1)头文件替换： #define endl ‘\n’<br>（2）直接输出’\n’</cstdio></p><hr><p>#容器</p><p>1.vector&lt;&gt;<br>动态可变长数组<br>vector&lt; int &gt; L &#x3D; {1,2,3,4,5};<br>&lt;图片001&gt;<br>（1）初始化<br>方法一：vector&lt; int &gt; L(n,100); &#x2F;&#x2F; L为名称，n为大小，100为初始值（可以省略，默认0）<br>方法二：vector&lt; int &gt; L &#x3D; {1,2,3};<br>方法三：vector&lt; int &gt; L；L.resize(n);</p><p>说明：resize(n)调整容器的大小，使其包含n个元素，如果n小于当前容器的大小，则将内容减少到其前n个元素，并删除超出范围的元素。</p><p>（2）输入<br>方法一：<br>int n;<br>vector&lt; int &gt; L;<br>for(int i&#x3D;0;i&lt;n;i++){<br>    int x;cin&gt;&gt;x;<br>    L.push_back(x);<br>}</p><p>说明：push_back（）函数将一个新的元素加到vector的最后面，位置为当前最后一个元素的下一个元素。</p><p>方法二：<br>int n;<br>vector&lt; int &gt; L(n);<br>for(int &amp;x:L){<br>    cin&gt;&gt;x;<br>}</p><p>说明：for(int a:b) 从数组b依次取出元素赋值给整型变量a，循环执行for中语句。<br>for(auto &amp;a:b)，循环体中修改a，b中对应内容也会修改。&#x2F;&#x2F;auto的原理就是根据后面的值，来自己推测前面的类型是什么。<br>auto的作用就是为了简化变量初始化，如果这个变量有一个很长很长的初始化类型，就可以用auto代替。<br>for(auto a:b)，循环体中修改a，b中内容不受影响。<br>for(const auto &amp;a:b)，a不可修改，用于只读取b中内容。</p><p>（3）遍历<br>方法一：<br>vector&lt; int &gt; L;<br>for(int i&#x3D;0;i&lt;L.size();i++){<br>    cout&lt;&lt;L[i]&lt;&lt;’\n’;<br>}</p><p>说明：L.size()为L的大小，为常数。</p><p>方法二：<br>vector&lt; int &gt; L;<br>for(auto i &#x3D; L.begin();i !&#x3D; L.end();i++){<br>    cout &lt;&lt; L[i] &lt;&lt; ‘\n’;<br>}</p><p>方法三：<br>vector&lt; int &gt; L;<br>for(int&amp; x:L){<br>    cout &lt;&lt; x &lt;&lt; ‘\n’;<br>}</p><p>（4）访问和修改<br>vector&lt; int &gt; L&#x3D;{1,2,3};<br>{<br>    int a &#x3D; L.at(0);   &#x2F;&#x2F;a&#x3D;1,L.at()不常用，知道即可。<br>    int b &#x3D; L[0];      &#x2F;&#x2F;b&#x3D;1<br>}</p><p>{<br>    int a &#x3D; L.front(); &#x2F;&#x2F;L.front()访问第一个数组。<br>    int b &#x3D; L.back();  &#x2F;&#x2F;L.back()访问最后一个数组。<br>}</p><p>L.push_back(4);&#x2F;&#x2F;L末尾加一个数组，其值为4，L:{1,2,3,4}<br>L.pop_back();&#x2F;&#x2F;去掉L末尾一个数组，L:{1,2,3}<br>L.emplace_back(4);&#x2F;&#x2F;功能与L.push_back(4)一样，逻辑不同。L:{1,2,3,4}<br>L.insert(L.begin(),5);&#x2F;&#x2F;插入一个值到某个数组，其后的数组的值往后移一位（末尾会增加一个数组）。L:{5,1,2,3,4}<br>L.erase(L.begin());&#x2F;&#x2F;删去L.begin()数组。L:{1,2,3,4}<br>L.erase(L.begin(),prew(L.end));&#x2F;&#x2F;删去L.begin()到prew(L.end)数组。L:{4}</p><p>说明：prew（）表示某个数组的前一个数组。</p><p>L.clear();&#x2F;&#x2F;清空数组。L:{}<br>L.empty();&#x2F;&#x2F;判断L是否为空。true</p><p>（5）二维矩阵<br>int n,m;<br>cin&gt;&gt;n&gt;&gt;m;<br>vector&lt;vector&lt; int &gt;&gt; L(n,vector&lt; int &gt;(m,0));&#x2F;&#x2F;得到n*m的二维矩阵，值为0。</p><p>2.string<br>（1）使用。<br>与c语言中的字符数组类似。<br>string s;<br>cin &gt;&gt; s;<br>s &#x3D; “hello world”;</p><p>s[0];&#x2F;&#x2F;‘h’<br>s.at(0);&#x2F;&#x2F;‘h’<br>s.front();&#x2F;&#x2F;‘h’<br>s.back();&#x2F;&#x2F;‘d’</p><p>s &#x3D; “abc”;<br>s.size();&#x2F;&#x2F;3<br>s.length();&#x2F;&#x2F;3,与s.size()功能相同。<br>s.empty();&#x2F;&#x2F;false</p><p>s &#x3D; “hello”;<br>s.clear();&#x2F;&#x2F;“”，清空。</p><p>s.insert(s.begin(),’c’);&#x2F;&#x2F;“chello”<br>s.insert(1,2,’p’);&#x2F;&#x2F;“cpphello”，在1的位置插入2个p。</p><p>s.erase(3);&#x2F;&#x2F;“cpp”，删掉3及其后面的字符。<br>s.erase(0,2);&#x2F;&#x2F;“p”，从0开始删除2个字符。<br>s.erase(s.begin(),s.end());&#x2F;&#x2F;“”，删除begin到end字符。</p><p>s &#x3D; “hello”;<br>s.push_back(‘x’);&#x2F;&#x2F;“hellox”<br>s.pop_back();&#x2F;&#x2F;“hello”</p><p>s +&#x3D; ‘ ‘;&#x2F;&#x2F;“hello “<br>s +&#x3D; “world”;&#x2F;&#x2F;“hello world”</p><p>注意尽量不要使用s &#x3D; s + “wo”类似语句，加大算法。</p><p>s.replace(0,5,”HELLO”);&#x2F;&#x2F;“HELLO world”，从0开始的5个字符替换为HELLO。</p><p>s &#x3D; “cppjava”;<br>s.substr(3);&#x2F;&#x2F;“java”，保留3及其以后字符。<br>s.substr(0,3);&#x2F;&#x2F;“cpp”,保留从0开始的3个字符。</p><p>s.find(“java”);&#x2F;&#x2F;3，查找字符的起始位置。<br>没找到时&#x2F;&#x2F;string::npos</p><p>string a &#x3D; “hello”;<br>string b &#x3D; “hello”;<br>if(a&#x3D;&#x3D;b){<br>    &#x2F;&#x2F;true，可以直接判断。<br>}</p><p>(2)数值转换<br>string s &#x3D; “123”;<br>int a &#x3D; stoi(s);&#x2F;&#x2F;将s转化为int类型。<br>long long b &#x3D; stoll(s);&#x2F;&#x2F;将s转化为long long类型。<br>double d &#x3D; stod(s);&#x2F;&#x2F;将s转化为double类型。</p><p>int x &#x3D; 1234;<br>string x_str &#x3D; to_string(x);&#x2F;&#x2F;将int类型转化为string类型。</p><p>（3）遍历<br>string s;<br>for(int i &#x3D; 0;i &lt; s.size();i++){<br>    char c &#x3D; s[i];<br>}<br>或<br>for(char c:s){</p><p>}</p><p>3.map&lt; Key,value &gt;<br>从Key映射到value。<br>（1）基本存取<br>map&lt; string,int &gt; mp;&#x2F;&#x2F;从string类型映射到int类型。</p><p>for(int i &#x3D; 0;i &lt; n;i++){<br>    string name;int age;<br>    cin&gt;&gt;name&gt;&gt;age;<br>    mp[name] &#x3D; age;&#x2F;&#x2F;从name映射到age；<br>}</p><p>mp[“Alice”] &#x3D; 14;&#x2F;&#x2F;string 的 Alice 映射到 int 的 14。<br>mp[“Bob”] &#x3D; 8;</p><p>cout &lt;&lt; mp[“Alice”]&lt;&lt; ‘\n’;&#x2F;&#x2F;14</p><p>(2)修改，删除<br>mp[“Alice”] &#x3D; 14;<br>mp[“Alice”] &#x3D; 15;&#x2F;&#x2F;直接修改。<br>cout&lt;&lt;mp[“Alice”];&#x2F;&#x2F;15</p><p>mp.erase(“Alice”);&#x2F;&#x2F;删除所有mp。<br>cout &lt;&lt; mp.count(“Alice”);&#x2F;&#x2F;0</p><p>说明：mp.count()指的是mp的个数。</p><p>cout &lt;&lt; mp[“Alice”];&#x2F;&#x2F;0，没有mp时，会创建一个为0的mp。<br>cout &lt;&lt; mp.count(“Alice”);&#x2F;&#x2F;1</p><p>（3）查看<br>mp[“Alice”] &#x3D; 15;<br>if(mp.find(“Alice”) !&#x3D; mp.end()){</p><p>}<br>或<br>if(mp.count(“Alice”)){</p><p>}</p><p>(4)遍历<br>map&lt; string,int &gt;mp;<br>for(auto x &#x3D; mp.begin(); x !&#x3D; mp.end();x++){<br>    string key &#x3D; x-&gt;first;<br>    int value &#x3D; x-&gt;second;<br>}<br>或<br>for(auto x : mp){<br>    string key &#x3D; x.first;<br>    int value &#x3D; x.second;<br>}<br>或<br>for(auto&amp; [k,v] : mp){ &#x2F;&#x2F;推荐该方式<br>    string key &#x3D; k;<br>    int value &#x3D; v;<br>}</p><p>3.ceil()<br>向上取整，可用于时间计算等。<br>（数据类型）ceil（n）<br>当n&#x3D;1.1时，ceil（）函数输出2；</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;1.头文件：（1）万能头文件： #include&amp;lt;bits&amp;#x2F;stdc++.h&amp;gt;&lt;br&gt;（2）加快c++中的输入输出：#define FIO ios::sync_with_stdio(0);cin.tie(0); &amp;#x2F;&amp;#x2F;不要忘记在mai</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>c++课堂笔记</title>
    <link href="http://example.com/2023/02/22/c++%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/2023/02/22/c++%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/</id>
    <published>2023-02-21T16:24:50.000Z</published>
    <updated>2023-02-28T10:38:05.423Z</updated>
    
    <content type="html"><![CDATA[<p><b>第一课时</b></p><ul><li>1.c++语言的头文件扩展名是  .h<br>c++语言的源程序文件的扩展名是  .cpp</li><li>2.c++使用cin和cout进行输入输出必须包含的头文件是  iostream<br>c++语言程序中使用控制符setw进行格式输出时应包含的头文件是  iomanip</li><li>3.cin和cout为c++中预定义的对象。<br>  “&gt;&gt;”称为流插入运算符，执行输入功能。<br>  “&lt;&lt;”称为流输出运算符，执行输出功能。</li><li>4.const与dedine定义变量的区别：（1）const与dedine都可以在c++中定义变量。<br>（2）const要定义常量的类型，define则不需要。如：#define PI 3.1415926，const float PI&#x3D;3.1415926;<br>（3）define不分配内存，const在静态存储区中分配空间。</li><li>5.（1）endl相当于\n<br>（2）setw(int n)是c++中在输出操作中使用的字段宽度设置，设置输出的域宽，n表示字段宽度。只对紧接着的输出有效，紧接着的输出结束后又变回默认的域宽。<br>当后面紧跟着的输出字段长度小于n的时候，在该字段前面用空格补齐（默认为右对齐）；当输出字段长度大于n时，全部整体输出。<br>（3）setfill（‘$’）表示将代替空格填充为$。<br>（3）left左对齐，right右对齐，都对于整个语句有效。<br>（4）setprecision(int n)，表示输出浮点值n位有效数字，可以四舍五入，只对邻近的有效。<br>（5）fixed写在setprecision(int n)之前，将输出浮点值n位，改为浮点值小数点后的n位。</li><li>6.dec表示十进制，hex表示十六进制，oct表示八进制。</li></ul><hr><p><b>第二课时</b></p><p>预习</p><ul><li>1.函数原型<br>在c语言中，函数定义：函数类型 函数名（形参列表）{ 函数体 }<br>函数原型：函数类型 函数名（形参列表）；其也可称为为 函数类型：函数首部；<br>函数原型的作用：可以避免函数先调用后定义的错误，即当函数原型在函数调用前时，可以先调用后定义。</li><li>2.函数重载<br>overload直译为重载，为了方便理解，可意译为多态，即多种形态。因此函数重载理解为同一函数多种形态。<br>函数重载条件：函数名相同，参数类型或参数个数不同。与函数类型无关，判断时忽略。<br>例如void f1(int a);与void f1(double d);是函数重载。<br>int max(int a);与int max(int a,int b);是。<br>void f2(int a);与int f2(int a);不是.<br>一般用于相同类型的运算，但具体功能有些差别的函数。</li><li>3.作用域运算符 ::<br>当程序中外部变量与内部变量重名时，内部变量屏蔽外部变量。<br>如果将变量x前加::,即变为::x输出时，则可输出外部变量。</li></ul><p>上课内容</p><p>课堂代码<br>#include&lt; iostream &gt;<br>using namespace std;<br>void area(int);<br>void area(int,int);<br>void area(int,int,int);<br>int main(){<br>int r,a,b,x,y,h;<br>cin&gt;&gt;r&gt;&gt;a&gt;&gt;b&gt;&gt;x&gt;&gt;y&gt;&gt;h;<br>area(r);<br>area(a,b);<br>area(x,y,h);<br>return 0;<br>}<br>void area(int r){<br>cout&lt;&lt;”圆的面积是：”&lt;&lt;r * r * 3.14&lt;&lt;endl;<br>}<br>void area(int a,int b){<br>cout&lt;&lt;”长方形的面积是：”&lt;&lt;a*b&lt;&lt;endl;<br>}<br>void area(int x,int y,int h){<br>cout&lt;&lt;”梯形的面积是：”&lt;&lt;(x+y)*h&#x2F;2.0&lt;&lt;endl;<br>}</p><p><b>第三课时</b></p><p>预习</p><ul><li><p>1.内置函数<br>又称内嵌函数，内联函数。其作用是使代码嵌入主调函数，省去函数调用的开销，即减少函数频繁调用消耗的时间，提高效率。<br>多用于频繁使用，且功能简单的函数。与普通函数相比，多出个inline，即<br>inline 函数类型 函数名 （形参列表）<br>  {函数体}</p></li><li><p>2.变量的引用<br>变量的引用就是变量的别名，因此引用又称别名。<br>引用的声明<br>数据类型 &amp;引用名&#x3D;已定义的变量名<br>int a &#x3D; 10;<br>int &amp;ra &#x3D; a;&#x2F;&#x2F;引用的数据类型必须与已定义的相同</p></li><li><p>3.引用传递<br>值传递<br>void f(int a);<br>地址传递<br>void f(int *p);<br>引用传递<br>void f(int &amp;r);<br>当引用作为函数的形参时，对应实参形参占用同一单元，形参与实参对应变化。</p></li></ul><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;b&gt;第一课时&lt;/b&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1.c++语言的头文件扩展名是  .h&lt;br&gt;c++语言的源程序文件的扩展名是  .cpp&lt;/li&gt;
&lt;li&gt;2.c++使用cin和cout进行输入输出必须包含的头文件是  iostream&lt;br&gt;c++语言程序中使用控制符</summary>
      
    
    
    
    
  </entry>
  
</feed>
